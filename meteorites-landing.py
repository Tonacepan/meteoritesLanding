# -*- coding: utf-8 -*-
"""Proyecto Mineria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vN-tfTdBPF4gE9UWQzhDhsSp4O2Ym1zZ
"""



"""Análisis:
* ¿En qué años se han registrado más impactos?
*¿En qué lugares se han registrado mas impactos de meteoritos?
*¿La mayoría de los meteoritos son pequeños o grandes?   
*¿Cuáles son los más comunes?
*Relación entre tamaño, tipo y ubicación
"""

# Importar librerias
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

#lectura de datos
from google.colab import drive
drive.mount('/content/drive')
!ls '/content/drive/MyDrive/Proyecto_mineria'
ruta = '/content/drive/MyDrive/Proyecto_mineria/meteorite-landings.csv'
data = pd.read_csv(ruta)

print(data.shape)
data.head()

data = data.drop(columns=['Unnamed: 10'])
data.info()

"""**Limpieza**
1. Datos faltantes
2. Columnas irrelevantes
3. Registros repetidos
4. Valores extremos
5. Errores tipográficos

**Datos faltantes**
Las columnas no tienen el mismo número de registros
data.dropna(inplace=True) sirve para eliminar datos que tengan el valor de "null", asegura que la modificación se realice directamente sobre el DataFrame original, sin crear una copia
"""

data.dropna(inplace=True)
data.info()

"""**Columnas irrelevantes**

Una columna se elimina si:

*  Una columna categórica pero con un sólo nivel.
* Columna que contiene información no relevante para el análisis
* Columna con un único valor
* Informacion redundante
"""

colum_cat=['recclass','mass','year','reclat','reclong']

for columna in colum_cat:
  print('...............................')
  print(f'Columna {columna}: {data[columna].nunique()} subniveles')

"""Ninguna de estas columnas categóricas es eliminada ya que tiene más de un subnivel

Describe estadísticamente la tendencia de los datos, su dispersión y distribución, de esta manera, podemos observar la distribución estandar, si tiene un valor similar a 0, quiere decir que casi todos los valores de esa columna son casi iguales, concluyendo que no hay variabilidad.
En nuestro dataset, no es el caso.
"""

data.describe()
data.info()

"""**Filas repetidas**

En nuestro dataset no hay filas repetidas
"""

print(f'Tamaño del set antes de eliminar las filas repetidas: {data.shape}')
data.drop_duplicates(inplace=True)
print(f'Tamaño del set después de eliminar las filas repetidas: {data.shape}')

data.info()

data = data.drop(columns=['id', 'name','GeoLocation'])
data.info()
data.head()

data['year'] = data['year'].astype(int)
data = data[data['mass'] > 0]
data.info()
data.head()

data.info()
data.head()

"""# Outliers

Se usa IQR.
Se deciden las columnas que queremos analizar (se excluye recclass ya que no se pueden gráficar estos valores con **boxplots**)
"""

# Columnas numéricas válidas para análisis
colum_num = ['mass', 'year', 'reclat', 'reclong']

# Configuracion del espacio de graficos
fig, ax = plt.subplots(nrows=len(colum_num), ncols=1, figsize=(10, 5 * len(colum_num)))
fig.subplots_adjust(hspace=0.5)

# Loop para cada columna numérica
for i, columna in enumerate(colum_num):
    # Calcular cuartiles
    Q1 = data[columna].quantile(0.25)
    Q3 = data[columna].quantile(0.75)
    #Calcular la zona segura
    IQR = Q3 - Q1

    # Límites para outliers: Todo valor fuera de los limites se considera un outlier
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Detectar outliers
    outliers = data[(data[columna] < lower_bound) | (data[columna] > upper_bound)]

    # Imprimir cantidad de outliers
    print(f"{columna} → tiene {len(outliers)} outliers")

    # Dibuja la grafica
    sns.boxplot(x=data[columna], ax=ax[i])
    ax[i].set_title(f'{columna} (outliers: {len(outliers)})')

"""Anotaciones:
* La masa está muy sesgada: muchos meteoritos pequeños y pocos enormes.
* A pesar que hay muchos outliers en nuestra columna year, tenemos que considerar que son datos reales y valiosos para el análisis.

# Columna year
"""

from datetime import datetime
año_max = datetime.now().year
print(f'Tamaño antes: {data.shape}')
# Eliminar registros con año NaN o fuera del rango válido
data = data.dropna(subset=['year'])
data = data[(data['year'] >= 1800) & (data['year'] <= año_max)]

print(f'Tamaño final del set: {data.shape}')

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 8))
data['year'].astype(int).plot.hist(bins=30, color='skyblue', edgecolor='black')
plt.title('Distribución de meteoritos por año')
plt.xlabel('Año')
plt.ylabel('Frecuencia')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Crear bins de décadas (ej: 1800-1809, 1810-1819, ...)
data['decade'] = pd.cut(data['year'],
                        bins=np.arange(data['year'].min() // 10 * 10,
                                     data['year'].max() // 10 * 10 + 20, 10),
                        right=False)  # Intervalo cerrado por la izquierda [a, b)

# Configurar el gráfico
plt.figure(figsize=(14, 7))
data['decade'].value_counts().sort_index().plot.bar(color='skyblue', edgecolor='black')

# Formatear etiquetas del eje X
plt.title('Distribución de meteoritos por década', fontsize=14)
plt.xlabel('Década', fontsize=12)
plt.ylabel('Número de meteoritos', fontsize=12)
plt.xticks(rotation=45, ha='right')  # Rotar etiquetas para legibilidad
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Mostrar el gráfico
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Agrupar datos por año
impactos_por_año = data.groupby('year').size()

# Crear gráfica
plt.figure(figsize=(12, 6))
impactos_por_año.plot()
plt.xlabel('Año')
plt.ylabel('Número de impactos')
plt.title('Impactos de meteoritos por año')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Agrupar datos por año y contar impactos
impactos_por_año = data['year'].value_counts().sort_index()  # Ordena por año

# Crear gráfica de barras (más adecuado para datos discretos como años)
plt.figure(figsize=(14, 6))
impactos_por_año.plot(kind='line', marker='o', linestyle='-', color='teal', markersize=4)
plt.xlabel('Año')
plt.ylabel('Número de impactos')
plt.title('Tendencia de impactos de meteoritos por año')
plt.grid(True)
plt.show()

"""#Columna masa

"""

print(f'Tamaño antes: {data.shape}')

# Eliminar valores nulos en 'mass'
data = data.dropna(subset=['mass'])

# Calcular límites usando IQR
Q1 = data['mass'].quantile(0.25)
Q3 = data['mass'].quantile(0.75)
IQR = Q3 - Q1

limite_inferior = Q1 - 1.5 * IQR
limite_superior = Q3 + 1.5 * IQR

# Eliminar registros fuera del rango
data = data[(data['mass'] >= limite_inferior) & (data['mass'] <= limite_superior)]

print(f'Tamaño final del set: {data.shape}')

plt.figure(figsize=(12, 8))
data['mass'].astype(int).plot.hist(bins=10, color='skyblue', edgecolor='black')
plt.title('Distribución de la masa de meteoritos')
plt.xlabel('Masa (gramos)')
plt.ylabel('Frecuencia')
plt.grid(True)
plt.show()

# 1. Crear categorías de masa
data['mass_category'] = pd.cut(data['mass'],
                             bins=[0, 100, 1_000, 10_000, np.inf],
                             labels=['<100g', '100g-1kg', '1kg-10kg', '>10kg'])

# 2. Contar meteoritos por categoría
category_counts = data['mass_category'].value_counts().sort_index()

# 3. Visualización
plt.figure(figsize=(10, 6))
bars = category_counts.plot(kind='bar', color='teal', edgecolor='black', alpha=0.7)

# Personalización del gráfico
plt.title('Distribución de meteoritos por categoría de masa', fontsize=14)
plt.xlabel('Categoría de masa', fontsize=12)
plt.ylabel('Número de meteoritos', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.6)

# Agregar etiquetas con los valores en cada barra
for bar in bars.patches:
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height(),
             f'{int(bar.get_height())}',
             ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## Distribución de meteoritos por territorio"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def get_continent_improved_ranges(lat, lon):
    # América del Norte (considerando una forma más irregular)
    if (15 <= lat <= 85 and -170 <= lon <= -50) or \
       (10 <= lat < 15 and -110 <= lon <= -80) or \
       (lat < 10 and -90 <= lon <= -80): # Parte de Centroamérica
        return "América del Norte"
    # América del Sur (ajustando los bordes)
    elif (-60 <= lat <= 15 and -85 <= lon <= -30) or \
         (-50 <= lat <= -15 and -75 <= lon <= -60): # Oeste de Sudamérica
        return "América del Sur"
    # África (con ajustes en los extremos)
    elif (-35 <= lat <= 38 and -20 <= lon <= 55) or \
         (lat > 30 and lon > 35): # Cuerno de África y Arabia
        return "África"
    # Europa (incluyendo islas y ajustando el este)
    elif (35 <= lat <= 75 and -25 <= lon <= 60) or \
         (lat > 60 and -10 <= lon < 30): # Escandinavia e islas
        return "Europa"
    # Asia (rangos muy amplios, difícil con rectángulos simples)
    elif (5 <= lat <= 80 and 25 <= lon <= 190) or \
         (lat > 50 and lon < 25) or \
         (lat < 5 and lon > 100):
        return "Asia"
    # Oceanía (Australia + islas del Pacífico)
    elif (-50 <= lat <= 15 and 100 <= lon <= 180) or \
         (-50 <= lat <= -10 and -180 <= lon <= -120) or \
         (-20 <= lat <= -5 and 150 <= lon <= 180): # Melanesia, Polinesia
        return "Oceanía"
    # Antártida
    elif lat <= -60:
        return "Antártida"
    else:
        return "Océano/Desconocido"

# Aplicar la función mejorada
data['continent_improved'] = data.apply(lambda row: get_continent_improved_ranges(row['reclat'], row['reclong']), axis=1)

# Recalcular los conteos con la nueva columna
continent_counts_improved = data['continent_improved'].value_counts()

# Gráfico de barras horizontal (usando los nuevos conteos)
plt.figure(figsize=(12, 6))
ax = continent_counts_improved.sort_values().plot(
    kind='barh',
    color=sns.color_palette('viridis', len(continent_counts_improved))
)
plt.title('Meteoritos registrados por continente (Rangos Mejorados)', fontsize=14)
plt.xlabel('Número de meteoritos')
plt.grid(axis='x', alpha=0.3)

# Añadir etiquetas de valor
for p in ax.patches:
    width = p.get_width()
    plt.text(width + 50, p.get_y() + p.get_height()/2,
             f'{int(width)}',
             ha='left', va='center')

plt.tight_layout()
plt.show()

"""## Distribución por clases

Meteoritos más comunes
"""

top_classes = data['recclass'].value_counts().head(10)

plt.figure(figsize=(12, 6))
top_classes.plot(kind='barh', color='darkcyan')
plt.title('Top 10 clases de meteoritos más comunes')
plt.xlabel('Número de registros')
plt.ylabel('Clase de meteorito')
plt.gca().invert_yaxis()  # Mostrar el más común arriba
plt.grid(axis='x')
plt.show()

"""# Relación entre clase y masa de meteoritos"""

import seaborn as sns

plt.figure(figsize=(12, 6))
sns.boxplot(data=data[data['mass'] < 5000],  # Filtrar para mejor visualización
            x='recclass',
            y='mass',
            order=data['recclass'].value_counts().index[:5])  # Top 5 clases
plt.xticks(rotation=45)
plt.yscale('log')
plt.title('Distribución de masa por clase (Top 5)')
plt.show()

# Obtener las 5 clases más comunes
top_5_clases = data['recclass'].value_counts().head(5).index

# Filtrar datos para solo esas clases
data_top5 = data[data['recclass'].isin(top_5_clases)]

# Calcular promedio y mediana
estadisticas_masa = data_top5.groupby('recclass')['mass'].agg(['count', 'mean', 'median']).sort_values(by='count', ascending=False)

# Redondear valores para mejor presentación
estadisticas_masa = estadisticas_masa.round(2)
estadisticas_masa

"""## Proporción meteoritos encontrados y observados"""

fall_counts = data['fall'].value_counts()

plt.figure(figsize=(8, 8))
plt.pie(fall_counts,
        labels=fall_counts.index,
        autopct='%1.1f%%',
        startangle=90,
        colors=['#ff9999','#66b3ff'])
plt.title('Proporción de meteoritos observados vs. encontrados')
plt.show()

!pip install folium
!pip install branca  # Requerido para algunos elementos visuales

data.head()
data.info()
data.describe()

# prompt: Necesito un mapa de calor con la información del dataset en un mapa del planeta tierra, revisa que la información que se muestra sea lo más exacta posible

import folium
from folium.plugins import HeatMap

# Asegurarse de que las columnas de latitud y longitud no tengan NaNs después del filtrado
data_heatmap = data.dropna(subset=['reclat', 'reclong'])

# Crear un mapa centrado en una ubicación global (ej. el centro del planeta)
# Ajustar el zoom inicial según sea necesario
world_map = folium.Map(location=[0, 0], zoom_start=2)

# Preparar los datos para el mapa de calor en el formato [lat, lon, weight]
# Usaremos un peso simple de 1 para cada punto, lo que indica la densidad de impactos
heat_data = [[row['reclat'], row['reclong'], 1] for index, row in data_heatmap.iterrows()]

# Agregar la capa de mapa de calor al mapa
HeatMap(heat_data).add_to(world_map)

# Mostrar el mapa
world_map

# prompt: Puedes separa el mapa anterior en distintos mapas por continentes

import pandas as pd
def create_continent_map(data, continent_name, map_center, zoom_start):
    """
    Crea un mapa Folium para un continente específico mostrando los impactos de meteoritos.

    Args:
        data (pd.DataFrame): DataFrame con los datos de meteoritos.
        continent_name (str): Nombre del continente a filtrar.
        map_center (list): Lista [latitud, longitud] para centrar el mapa.
        zoom_start (int): Nivel de zoom inicial para el mapa.

    Returns:
        folium.Map: El objeto mapa de Folium para el continente.
    """
    continent_data = data[data['continent_improved'] == continent_name].dropna(subset=['reclat', 'reclong'])

    # Crear un mapa centrado en el continente
    continent_map = folium.Map(location=map_center, zoom_start=zoom_start)

    # Preparar los datos para el mapa de calor [lat, lon, weight]
    heat_data = [[row['reclat'], row['reclong'], 1] for index, row in continent_data.iterrows()]

    # Agregar la capa de mapa de calor
    if heat_data: # Solo agregar si hay datos para evitar errores
        HeatMap(heat_data).add_to(continent_map)

    return continent_map

# Definir centros aproximados y zooms para cada continente
continent_maps_info = {
    "América del Norte": {"center": [40, -100], "zoom": 3},
    "América del Sur": {"center": [-20, -60], "zoom": 3},
    "África": {"center": [5, 20], "zoom": 3},
    "Europa": {"center": [50, 10], "zoom": 4},
    "Asia": {"center": [30, 90], "zoom": 3},
    "Oceanía": {"center": [-25, 135], "zoom": 3},
    "Antártida": {"center": [-80, 0], "zoom": 2},
    # No se crea mapa para 'Océano/Desconocido' ya que no tiene una ubicación geográfica clara
}

# Generar y mostrar los mapas por continente
for continent, info in continent_maps_info.items():
    print(f"Generando mapa para: {continent}")
    continent_map = create_continent_map(data, continent, info["center"], info["zoom"])
    # Para mostrar cada mapa en un cuaderno, se imprime el objeto mapa.
    # Cada celda en Colab o Jupyter mostrará el último objeto "imprimible".
    # Si quieres ver todos, necesitarías mostrarlos secuencialmente o guardarlos.
    # Aquí los mostraremos uno tras otro.
    display(continent_map) # Usar display para mostrar objetos Folium correctamente en notebooks

# Si quieres guardar los mapas como archivos HTML:
# for continent, info in continent_maps_info.items():
#     continent_map = create_continent_map(data, continent, info["center"], info["zoom"])
#     continent_map.save(f'{continent.replace(" ", "_").lower()}_meteorite_map.html')
# print("Mapas guardados como archivos HTML.")

